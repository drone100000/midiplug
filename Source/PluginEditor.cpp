/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "juce_Logger.h"

//==============================================================================
/** Another really simple look and feel that is very flat and square.
 This inherits from CustomLookAndFeel above for the linear bar and slider backgrounds.
 */
struct SquareLookAndFeel    : public LookAndFeel_V3
{
    void drawButtonBackground (Graphics& g, Button& button, const Colour& backgroundColour,
                               bool isMouseOverButton, bool isButtonDown) override
    {
        Colour baseColour (backgroundColour.withMultipliedSaturation (button.hasKeyboardFocus (true) ? 1.3f : 0.9f)
                           .withMultipliedAlpha (button.isEnabled() ? 0.9f : 0.5f));

        if (isButtonDown || isMouseOverButton)
            baseColour = baseColour.contrasting (isButtonDown ? 0.2f : 0.1f);

        const float width  = button.getWidth() - 1.0f;
        const float height = button.getHeight() - 1.0f;

        if (width > 0 && height > 0)
        {
            g.setGradientFill (ColourGradient (baseColour, 0.0f, 0.0f,
                                               baseColour.darker (0.1f), 0.0f, height,
                                               false));

            g.fillRect (button.getLocalBounds());
        }
    }

    void drawTickBox (Graphics& g, Component& component,
                      float x, float y, float w, float h,
                      bool ticked,
                      bool isEnabled,
                      bool /*isMouseOverButton*/,
                      bool /*isButtonDown*/) override
    {
        const float boxSize = w * 0.7f;

        bool isDownOrDragging = component.isEnabled() && (component.isMouseOverOrDragging() || component.isMouseButtonDown());
        const Colour colour (component.findColour (TextButton::buttonOnColourId).withMultipliedSaturation ((component.hasKeyboardFocus (false) || isDownOrDragging) ? 1.3f : 0.9f)
                             .withMultipliedAlpha (component.isEnabled() ? 1.0f : 0.7f));
        g.setColour (colour);

        Rectangle<float> r (x, y + (h - boxSize) * 0.5f, boxSize, boxSize);
        g.fillRect (r);

        if (ticked)
        {
            const Path tick (LookAndFeel_V3::getTickShape (6.0f));
            g.setColour (isEnabled ? findColour (TextButton::buttonColourId) : Colours::grey);

            const AffineTransform trans (RectanglePlacement (RectanglePlacement::centred)
                                         .getTransformToFit (tick.getBounds(), r.reduced (r.getHeight() * 0.05f)));
            g.fillPath (tick, trans);
        }
    }

    void drawLinearSliderThumb (Graphics& g, int x, int y, int width, int height,
                                float sliderPos, float minSliderPos, float maxSliderPos,
                                const Slider::SliderStyle style, Slider& slider) override
    {
        const float sliderRadius = (float) getSliderThumbRadius (slider);

        bool isDownOrDragging = slider.isEnabled() && (slider.isMouseOverOrDragging() || slider.isMouseButtonDown());
        Colour knobColour (slider.findColour (Slider::rotarySliderFillColourId).withMultipliedSaturation ((slider.hasKeyboardFocus (false) || isDownOrDragging) ? 1.3f : 0.9f)
                           .withMultipliedAlpha (slider.isEnabled() ? 1.0f : 0.7f));
        g.setColour (knobColour);

        if (style == Slider::LinearHorizontal || style == Slider::LinearVertical)
        {
            float kx, ky;

            if (style == Slider::LinearVertical)
            {
                kx = x + width * 0.5f;
                ky = sliderPos;
                g.fillRect (Rectangle<float> (kx - sliderRadius, ky - 2.5f, sliderRadius * 2.0f, 5.0f));
            }
            else
            {
                kx = sliderPos;
                ky = y + height * 0.5f;
                g.fillRect (Rectangle<float> (kx - 2.5f, ky - sliderRadius, 5.0f, sliderRadius * 2.0f));
            }
        }
        else
        {
            // Just call the base class for the demo
            LookAndFeel_V2::drawLinearSliderThumb (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
        }
    }

    /*void drawRotarySlider (Graphics& g, int x, int y, int width, int height, float sliderPos,
                           float rotaryStartAngle, float rotaryEndAngle, Slider& slider) override
    {
        const float diameter = jmin (width, height) - 4.0f;
        const float radius = (diameter / 2.0f) * std::cos (float_Pi / 4.0f);
        const float centreX = x + width * 0.5f;
        const float centreY = y + height * 0.5f;
        const float rx = centreX - radius;
        const float ry = centreY - radius;
        const float rw = radius * 2.0f;
        const float angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
        const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

        const Colour baseColour (slider.isEnabled() ? slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 0.8f : 1.0f)
                                 : Colour (0x80808080));

        Rectangle<float> r (rx, ry, rw, rw);
        AffineTransform t (AffineTransform::rotation (angle, r.getCentreX(), r.getCentreY()));

        float x1 = r.getTopLeft().getX(), y1 = r.getTopLeft().getY(), x2 = r.getBottomLeft().getX(), y2 = r.getBottomLeft().getY();
        t.transformPoints (x1, y1, x2, y2);

        g.setGradientFill (ColourGradient (baseColour, x1, y1,
                                           baseColour.darker (0.1f), x2, y2,
                                           false));

        Path knob;
        knob.addRectangle (r);
        g.fillPath (knob, t);

        Path needle;
        Rectangle<float> r2 (r * 0.1f);
        needle.addRectangle (r2.withPosition (Point<float> (r.getCentreX() - (r2.getWidth() / 2.0f), r.getY())));

        g.setColour (slider.findColour (Slider::rotarySliderOutlineColourId));
        g.fillPath (needle, AffineTransform::rotation (angle, r.getCentreX(), r.getCentreY()));
    }*/
};

void MidiplugAudioProcessorEditor::setupSquareLookAndFeelColors (LookAndFeel& laf)
{
    const Colour baseColour (Colours::red);
    laf.setColour (Slider::thumbColourId, Colour::greyLevel (0.95f));
    //Text box outline
    laf.setColour (Slider::textBoxOutlineColourId, Colours::white);
    //Slider fill/pointer
    laf.setColour (Slider::rotarySliderFillColourId, baseColour);
    //Slider outline
    laf.setColour (Slider::rotarySliderOutlineColourId, Colours::black);
    laf.setColour (Slider::trackColourId, Colours::black);

    //Increment/decrement buttons
    laf.setColour (TextButton::buttonColourId, Colours::whitesmoke);
    laf.setColour (TextButton::textColourOffId, baseColour);

    laf.setColour (TextButton::buttonOnColourId, laf.findColour (TextButton::textColourOffId));
    laf.setColour (TextButton::textColourOnId, laf.findColour (TextButton::buttonColourId));
}

//==============================================================================
MidiplugAudioProcessorEditor::MidiplugAudioProcessorEditor (MidiplugAudioProcessor& owner)
    : AudioProcessorEditor (owner),
      channelSlider ("Channel"),
      valueSlider ("Value")
{
    // This is where our plugin's editor size is set.
    setSize (400, 300);

    // add some sliders..
    Logger::writeToLog("TEST");
    addAndMakeVisible (channelSlider);
    channelSlider.setSliderStyle (Slider::IncDecButtons);
    channelSlider.addListener (this);
    channelSlider.setRange (0, 16, 1);
    //channelSlider.setTextBoxStyle(Slider::NoTextBox, false, 0, 0);

    addAndMakeVisible (valueSlider);
    valueSlider.setSliderStyle (Slider::Rotary);
    valueSlider.addListener (this);
    valueSlider.setRange (0, 127, 1);
    //channelSlider.setTextBoxStyle(Slider::NoTextBox, false, 0, 0);

    SquareLookAndFeel* slaf = new SquareLookAndFeel();
    setupSquareLookAndFeelColors(*slaf);
    setLookAndFeel(slaf);

    startTimer(50);

}

MidiplugAudioProcessorEditor::~MidiplugAudioProcessorEditor()
{
}

//this is taken from JuceDemoPlugin
void MidiplugAudioProcessorEditor::resized()
{
    channelSlider.setBounds (10, 10, 150, 20);
    valueSlider.setBounds (10, 35, 150, 40);

    /*
    resizer->setBounds (getWidth() - 16, getHeight() - 16, 16, 16);

    getProcessor().lastUIWidth = getWidth();
    getProcessor().lastUIHeight = getHeight();
     */
}

//this is from JuceDemoPlugin
void MidiplugAudioProcessorEditor::timerCallback()
{
    MidiplugAudioProcessor& ourProcessor = getProcessor();

    channelSlider.setValue (ourProcessor.getParameter(ourProcessor.channelParam), dontSendNotification);
    valueSlider.setValue (ourProcessor.getParameter(ourProcessor.programParam), dontSendNotification);
}

// This is our Slider::Listener callback, when the user drags a slider.
// Taken from the JuceDemoPlugin
void MidiplugAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (slider == &channelSlider)
    {
        // It's vital to use setParameterNotifyingHost to change any parameters that are automatable
        // by the host, rather than just modifying them directly, otherwise the host won't know
        // that they've changed.
        getProcessor().setParameterNotifyingHost (MidiplugAudioProcessor::channelParam,
                                                  (float) channelSlider.getValue());
    }
    else if (slider == &valueSlider)
    {
        getProcessor().setParameterNotifyingHost (MidiplugAudioProcessor::programParam,
                                                  (float) valueSlider.getValue());
    }
}

//==============================================================================
void MidiplugAudioProcessorEditor::paint (Graphics& g)
{
    g.setGradientFill (ColourGradient (Colours::grey, 0, 0,
                                       Colours::black, 0, (float) getHeight(), false));
    g.fillAll();
    g.setColour (Colours::black);
    g.setFont (15.0f);
    //g.drawFittedText(displayText+"!!", 0, 0, getWidth(), getHeight(), Justification::centred, 1);
}
